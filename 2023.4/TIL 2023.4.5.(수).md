# TIL 2023.4.5.(수)
# Keychain Services
* 대부분의 유저들은 안전하게 사용해야할 작은 비밀들이 있다.(예를들어, 온라인 계정과 같은)
* 복잡하고 유니크한 패스워드를 기억하는 것은 불가능하지만, 그것을 적는거는 안전하지 않고 지루하다.
* 또한 많은 부분에 대해 간단한 패스워드를 재활용하는 것은 보안상으로도 좋지않다.
* Keychain API는 키체인을 불러 암호화된 데이터를 저장하여 위 문제를 해결할 수 있도록 해준다.
* 유저들의 비밀번호를 안전하게 기억하고 싶을 때, 유저에게 줄 수 있는 선택권중 하나이다.

![](https://docs-assets.developer.apple.com/published/0ddea9db46/1c9e8103-fae2-45f4-832c-c528d2e0c2f6.png)

* 키체인은 단순히 비밀번호에만 국한되는것이 아닌 위 사진과 같이 여러 보안정보들을 다룰 수 있다.

# UserDefaults
* 앱 런칭에 따라 키-밸류 쌍들로 저장하는 영구적인 유저만의 데이터베이스를 사용할 수 있는 인터페이스

## Overview
* `UserDefault`클래스는 기본적인 시스템이랑 상호작용할 수 있는 인터페이스를 제공한다.
* 기본적인 시스템은 앱에서 개인유저가 선호하는 설정(비디오 플레이어 되돌리기 시간 등등) 을 접근할 수 있게 해준다.
* 이러한 설정들을 `user’s defaults database`를 통하여 파라미터 값으로 할당하여 앱에 저장한다.
* 런타임 시 우리는 `UserDefaults`객체를 사용하여 데이터베이스로 부터 기본 값을 읽는다.
* `UserDefault`는 정보를 캐쉬(임시적으로 저장)하는데 이는 값이 불릴때마다 데이터베이스에 접근하는 것을 피하기 위함이다.

## Storing Default Objects
* `UserDefaults`클래스는 일반적인 `float`, `URL`, `Bollean`과 같은 값에 접근하기 위해 편리한 메소드들을 제공한다.
* 기본적인 객체는 `NSData`, `NSString`, `NSDictionary`와 같은 프로퍼티 리스트어야한다. 이 말고 다른 타입을 저장하기 위해서는 `NSData`의 인스턴스를 생성하여 보관하여야한다.
* `UserDefaults`에서 받아온 값들은 변경할 수 없다. 이는 단순히 변수 선언여부와 상관없이 불가능하다. 만약 `ABCDE`라는 문자열을 만들었어도 이후 `string(forKey:)`메소드를 통해서 받아온 값은 바꿀 수가 없다.
* 만약 값을 변경하고 싶다면 `set(_:forKey:)`메소드를 통해서 변경하여야 한다.

## Persisting File References
* 파일 URL은 현재 파일 시스템의 위치를 가르킨다.
* 만약 `set`메소드를 통하여 현재 파일을 저장한 이후에 유저가 해당 파일을 옮겼다면 앱은 다음 실행 때 해당 파일을 찾지 못할 것이다.
* 그렇기 때문에 파일 시스템의 identity 즉 참조된것을 저장해야한다. 이는 `NSURL`의 북마크 데이터를 통해서 생성할 수 있다.

## Responding to Defaults Changes
* 우리는 키 밸류 옵저방이르 사용하여 기본 값의 특정부분이 변경된 것을 알 수 있다.
* 이는 `didChangeNotification`이라는 노티피케이션 센터를 등록할 수 있다.

## Using Defaults in Managed Environments
* 관리되는 환경(컴퓨터실, 교실)등 에서 사용하는 앱을 관리하기 위해서는 관리자가 직접 기본설정을 사용할 수 있다.
* 다만, 이럴경우 사용자가 해당 기본정보를 수정하지 못하도록 접근을 막아야한다.
* 교육기관에서 사용한다면 iCloud를 통해 사용자 기기의 정보를 저장할 수 있다.
* 예를들어, 사용자가 교과서를 보고 있다면 해당 페이지를 저장하여 다음에 앱을 실행할 경우 그 페이지를 다시 볼 수 있도록 만들 수 있다.

## Sandbox Considerations
* 샌드박스 앱의 경우 다른 앱에 접근을 할 수 없지만, 다음과 같은 경우에는 접근할 수 있다
	1. macOS 그리고 iOS앱의 확장 앱일경우
	2. macOS내의 사용자 어플리케이션 그룹 내의 다른 앱들
* 다만, 위와 같은 경우에도 `addSuite(named:)`를 사용할 경우 다른 써드파티 앱들이 접근할 수 없도록 만들 수 있다.
* 만약, 다른 앱의 접근을 시도하려한다면 이는 에러를 발생하지 않고 단지 현재앱의 파일만을 읽을 뿐이다.